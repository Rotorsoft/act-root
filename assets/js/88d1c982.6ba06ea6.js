"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["8946"],{6077:function(e,i,t){t.r(i),t.d(i,{frontMatter:()=>a,default:()=>u,toc:()=>c,metadata:()=>n,assets:()=>o,contentTitle:()=>l});var n=JSON.parse('{"id":"concepts/utilities","title":"Utilities","description":"Background","source":"@site/docs/concepts/utilities.md","sourceDirName":"concepts","slug":"/concepts/utilities","permalink":"/act-root/docs/concepts/utilities","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/utilities.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Event Sourcing","permalink":"/act-root/docs/concepts/event-sourcing"},"next":{"title":"Configuration","permalink":"/act-root/docs/concepts/configuration"}}'),s=t(4381),r=t(1261);let a={},l="Utilities",o={},c=[{value:"Background",id:"background",level:2},{value:"State Patching",id:"state-patching",level:2},{value:"Validation",id:"validation",level:2},{value:"Async Helpers",id:"async-helpers",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){let i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"utilities",children:"Utilities"})}),"\n",(0,s.jsx)(i.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(i.p,{children:"Utilities are supporting tools and helpers that streamline common tasks such as state patching, validation, and asynchronous operations. By providing robust, reusable utilities, the Act Framework reduces boilerplate and helps developers focus on core business logic. These utilities are designed to be composable and type-safe, ensuring reliability and maintainability."}),"\n",(0,s.jsx)(i.h2,{id:"state-patching",children:"State Patching"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Immutably update state in response to events using provided utilities."}),"\n",(0,s.jsx)(i.li,{children:"Utilities help avoid direct mutation and ensure predictable state transitions."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"validation",children:"Validation"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Schema validation and error handling are built-in, leveraging Zod for type-safe schemas."}),"\n",(0,s.jsx)(i.li,{children:"Use validation utilities to enforce business rules and invariants."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"async-helpers",children:"Async Helpers"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Utilities for working with asynchronous operations, such as delays, retries, and scheduling."}),"\n",(0,s.jsx)(i.li,{children:"Async helpers simplify integration with external systems and workflows."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Use provided utilities to reduce boilerplate and improve reliability."}),"\n",(0,s.jsx)(i.li,{children:"Prefer immutable updates and type-safe validation."}),"\n",(0,s.jsx)(i.li,{children:"Leverage async helpers for robust, reactive workflows."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.a,{href:"../api/act.src",children:"API Reference (act)"})})]})}function u(e={}){let{wrapper:i}={...(0,r.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1261:function(e,i,t){t.d(i,{Z:()=>l,a:()=>a});var n=t(3749);let s={},r=n.createContext(s);function a(e){let i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);