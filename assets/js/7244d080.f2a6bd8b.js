"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8600],{537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"concepts/state-management","title":"State Management","description":"Background","source":"@site/docs/concepts/state-management.md","sourceDirName":"concepts","slug":"/concepts/state-management","permalink":"/act-root/docs/concepts/state-management","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/state-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Builders","permalink":"/act-root/docs/concepts/builders"},"next":{"title":"Event Sourcing","permalink":"/act-root/docs/concepts/event-sourcing"}}');var s=n(7968),o=n(4318);const i={},r="State Management",c={},d=[{value:"Background",id:"background",level:2},{value:"State Definition",id:"state-definition",level:2},{value:"Actions &amp; Events",id:"actions--events",level:2},{value:"Validation",id:"validation",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"state-management",children:"State Management"})}),"\n",(0,s.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(t.p,{children:"State management is at the heart of any application that tracks and evolves data over time. In this framework, state is modeled as a series of transitions driven by actions and recorded as events. This approach enables powerful features such as time travel, auditing, and debugging, as you can always reconstruct the state from its event history. Strong typing and validation ensure that state transitions are predictable and safe."}),"\n",(0,s.jsx)(t.h2,{id:"state-definition",children:"State Definition"}),"\n",(0,s.jsx)(t.p,{children:"Define your domain models as state machines, specifying the shape of state and how it evolves over time."}),"\n",(0,s.jsx)(t.h2,{id:"actions--events",children:"Actions & Events"}),"\n",(0,s.jsx)(t.p,{children:"Actions represent commands to change state. Events are the immutable records of those changes. The framework provides strong typing and validation for both."}),"\n",(0,s.jsx)(t.h2,{id:"validation",children:"Validation"}),"\n",(0,s.jsx)(t.p,{children:"Business rules and invariants can be enforced at the action and event level, ensuring your domain remains consistent."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"../api/act.src",children:"API Reference (act)"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"../api/act-pg",children:"API Reference (act-pg)"})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4318:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(4700);const s={},o=a.createContext(s);function i(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);