"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["9588"],{4240:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>r,default:()=>h,toc:()=>d,metadata:()=>a,assets:()=>c,contentTitle:()=>o});var a=JSON.parse('{"id":"concepts/state-management","title":"State Management","description":"Background","source":"@site/docs/concepts/state-management.md","sourceDirName":"concepts","slug":"/concepts/state-management","permalink":"/act-root/docs/concepts/state-management","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/state-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Builders","permalink":"/act-root/docs/concepts/builders"},"next":{"title":"Event Sourcing","permalink":"/act-root/docs/concepts/event-sourcing"}}'),s=n(4381),i=n(1261);let r={},o="State Management",c={},d=[{value:"Background",id:"background",level:2},{value:"State Definition",id:"state-definition",level:2},{value:"Actions &amp; Events",id:"actions--events",level:2},{value:"Validation",id:"validation",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(e){let t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"state-management",children:"State Management"})}),"\n",(0,s.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,s.jsx)(t.p,{children:"State management is at the heart of any application that tracks and evolves data over time. In the Act Framework, state is modeled as a series of transitions driven by actions and recorded as events. This approach enables powerful features such as time travel, auditing, and debugging, as you can always reconstruct the state from its event history. Strong typing and validation ensure that state transitions are predictable and safe."}),"\n",(0,s.jsx)(t.h2,{id:"state-definition",children:"State Definition"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Define your domain models as state machines, specifying the shape of state and how it evolves over time."}),"\n",(0,s.jsx)(t.li,{children:"Use Zod schemas for type-safe state definitions and validation."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"actions--events",children:"Actions & Events"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Actions represent commands to change state."}),"\n",(0,s.jsx)(t.li,{children:"Events are the immutable records of those changes."}),"\n",(0,s.jsx)(t.li,{children:"The framework provides strong typing and validation for both actions and events."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"validation",children:"Validation"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Business rules and invariants can be enforced at the action and event level, ensuring your domain remains consistent."}),"\n",(0,s.jsx)(t.li,{children:"Use Zod and custom logic to validate all transitions."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Keep state machines focused and single-purpose."}),"\n",(0,s.jsx)(t.li,{children:"Validate all actions and events."}),"\n",(0,s.jsx)(t.li,{children:"Use event history for debugging and analytics."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"../api/act.src",children:"API Reference (act)"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"../api/act-pg",children:"API Reference (act-pg)"})})]})}function h(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1261:function(e,t,n){n.d(t,{Z:()=>o,a:()=>r});var a=n(3749);let s={},i=a.createContext(s);function r(e){let t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);