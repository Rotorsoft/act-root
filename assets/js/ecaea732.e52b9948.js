"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4854],{4318:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var a=n(4700);const r={},o=a.createContext(r);function s(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},4980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"concepts/core-framework","title":"Core Framework","description":"Background","source":"@site/docs/concepts/core-framework.md","sourceDirName":"concepts","slug":"/concepts/core-framework","permalink":"/act-root/docs/concepts/core-framework","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/core-framework.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Act Framework","permalink":"/act-root/docs/intro"},"next":{"title":"Builders","permalink":"/act-root/docs/concepts/builders"}}');var r=n(7968),o=n(4318);const s={},c="Core Framework",i={},d=[{value:"Background",id:"background",level:2},{value:"Act Class",id:"act-class",level:2},{value:"Event Management",id:"event-management",level:2},{value:"State Loading",id:"state-loading",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"core-framework",children:"Core Framework"})}),"\n",(0,r.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,r.jsx)(t.p,{children:"The core framework of this project is designed to orchestrate event-sourced state machines, providing a robust foundation for building reliable, auditable, and scalable applications. Event sourcing ensures that every change to the application state is captured as an immutable event, allowing for complete traceability and the ability to reconstruct state at any point in time. This approach is particularly valuable in domains where auditability, debugging, and historical analysis are important. The framework abstracts the complexities of event management, state reconstruction, and coordination of actions and reactions, enabling developers to focus on domain logic while leveraging powerful infrastructure for state and event handling."}),"\n",(0,r.jsx)(t.h2,{id:"act-class",children:"Act Class"}),"\n",(0,r.jsx)(t.p,{children:"The main orchestrator for event-sourced state machines. It manages the registration of state machines, event processing, and coordination of actions and reactions."}),"\n",(0,r.jsx)(t.h2,{id:"event-management",children:"Event Management"}),"\n",(0,r.jsx)(t.p,{children:"Events are processed and committed to the event store, ensuring all state changes are captured as immutable events. The framework provides utilities for querying and analyzing event streams."}),"\n",(0,r.jsx)(t.h2,{id:"state-loading",children:"State Loading"}),"\n",(0,r.jsx)(t.p,{children:"State is reconstructed from event streams, allowing you to rebuild the current state of any domain object at any time. Snapshots can be used to optimize this process for large streams."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"../api/act.src",children:"API Reference (act)"})})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);