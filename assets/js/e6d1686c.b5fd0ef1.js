"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["5944"],{5002:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>o,default:()=>u,toc:()=>l,metadata:()=>s,assets:()=>i,contentTitle:()=>c});var s=JSON.parse('{"id":"concepts/ports-adapters","title":"Ports & Adapters","description":"Background","source":"@site/docs/concepts/ports-adapters.md","sourceDirName":"concepts","slug":"/concepts/ports-adapters","permalink":"/act-root/docs/concepts/ports-adapters","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/ports-adapters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Configuration","permalink":"/act-root/docs/concepts/configuration"},"next":{"title":"Calculator Example","permalink":"/act-root/docs/examples/calculator"}}'),r=n(4381),a=n(1261);let o={},c="Ports & Adapters",i={},l=[{value:"Background",id:"background",level:2},{value:"Store Adapters",id:"store-adapters",level:2},{value:"Resource Management",id:"resource-management",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){let t={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"ports--adapters",children:"Ports & Adapters"})}),"\n",(0,r.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,r.jsx)(t.p,{children:"The Ports & Adapters (Hexagonal) architecture decouples the core logic of your application from external systems such as databases, message queues, or web services. By defining clear interfaces (ports) and providing interchangeable implementations (adapters), this pattern enables flexibility, testability, and maintainability. In the Act Framework, store adapters allow you to swap out storage backends without changing your business logic, and resource management ensures that external connections are handled efficiently and safely."}),"\n",(0,r.jsx)(t.h2,{id:"store-adapters",children:"Store Adapters"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Pluggable storage backends allow you to use different databases or event stores with the same application code."}),"\n",(0,r.jsx)(t.li,{children:"Easily switch between in-memory and persistent stores (e.g., Postgres) for development, testing, and production."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"resource-management",children:"Resource Management"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Lifecycle management for external resources, such as database connections or message queues, is handled through a consistent interface."}),"\n",(0,r.jsx)(t.li,{children:"Proper resource management ensures reliability and prevents leaks or connection exhaustion."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Define clear interfaces for all external dependencies."}),"\n",(0,r.jsx)(t.li,{children:"Use adapters to isolate infrastructure concerns from business logic."}),"\n",(0,r.jsx)(t.li,{children:"Test with in-memory adapters and deploy with production-grade stores."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"../api/act.src",children:"API Reference (act)"})})]})}function u(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1261:function(e,t,n){n.d(t,{Z:()=>c,a:()=>o});var s=n(3749);let r={},a=s.createContext(r);function o(e){let t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);