"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["2402"],{810:function(e,t,s){s.r(t),s.d(t,{frontMatter:()=>a,toc:()=>c,default:()=>h,metadata:()=>n,assets:()=>l,contentTitle:()=>i});var n=JSON.parse('{"id":"concepts/configuration","title":"Builders & Adapters","description":"Tips for Builders & Adapters","source":"@site/docs/concepts/configuration.md","sourceDirName":"concepts","slug":"/concepts/configuration","permalink":"/act-root/docs/concepts/configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/configuration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Event Sourcing","permalink":"/act-root/docs/concepts/event-sourcing"},"next":{"title":"Calculator Example","permalink":"/act-root/docs/examples/calculator"}}'),r=s(3302),o=s(6752);let a={},i="Builders & Adapters",l={},c=[{value:"Tips for Builders &amp; Adapters",id:"tips-for-builders--adapters",level:2},{value:"Example 1: Composing State Machines with Builders",id:"example-1-composing-state-machines-with-builders",level:2},{value:"Example 2: Using a Postgres or Custom Store Adapter",id:"example-2-using-a-postgres-or-custom-store-adapter",level:2},{value:"How to Build a Custom Store Adapter",id:"how-to-build-a-custom-store-adapter",level:2},{value:"Advanced: Lease Management &amp; Reliable Event Stream Processing",id:"advanced-lease-management--reliable-event-stream-processing",level:2},{value:"What is a Lease?",id:"what-is-a-lease",level:3},{value:"Key Methods",id:"key-methods",level:3},{value:"Challenges",id:"challenges",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Sample Lease Table Schema (for SQL-based stores)",id:"sample-lease-table-schema-for-sql-based-stores",level:3},{value:"Summary Table",id:"summary-table",level:3}];function d(e){let t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"builders--adapters",children:"Builders & Adapters"})}),"\n",(0,r.jsx)(t.h2,{id:"tips-for-builders--adapters",children:"Tips for Builders & Adapters"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Use ",(0,r.jsx)(t.code,{children:"StateBuilder"})," to define state machines, actions, events, and validation logic in a fluent, type-safe way."]}),"\n",(0,r.jsxs)(t.li,{children:["Use ",(0,r.jsx)(t.code,{children:"ActBuilder"})," to compose applications from multiple state machines and reactions."]}),"\n",(0,r.jsx)(t.li,{children:"Adapters allow you to swap event stores (e.g., in-memory, Postgres, custom) without changing business logic."}),"\n",(0,r.jsx)(t.li,{children:"Use reactions to decouple workflows and integrate with external systems."}),"\n",(0,r.jsx)(t.li,{children:"Visualize your application architecture to clarify how builders and adapters interact."}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"example-1-composing-state-machines-with-builders",children:"Example 1: Composing State Machines with Builders"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Scenario:"}),"\nYou want to define two state machines (e.g., a Counter and a TodoList) and compose them into a single application using ",(0,r.jsx)(t.code,{children:"ActBuilder"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { act, state, z } from "@rotorsoft/act";\n\nconst Counter = state("Counter", z.object({ count: z.number() }))\n  .init(() => ({ count: 0 }))\n  .emits({ Incremented: z.object({ amount: z.number() }) })\n  .patch({\n    Incremented: (event, state) => ({ count: state.count + event.amount }),\n  })\n  .on("increment", z.object({ by: z.number() }))\n  .emit((action) => ["Incremented", { amount: action.by }])\n  .build();\n\nconst TodoList = state("TodoList", z.object({ todos: z.array(z.string()) }))\n  .init(() => ({ todos: [] }))\n  .emits({ Added: z.object({ todo: z.string() }) })\n  .patch({\n    Added: (event, state) => ({ todos: [...state.todos, event.todo] }),\n  })\n  .on("add", z.object({ todo: z.string() }))\n  .emit((action) => ["Added", { todo: action.todo }])\n  .build();\n\nconst app = act().with(Counter).with(TodoList).build();\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"example-2-using-a-postgres-or-custom-store-adapter",children:"Example 2: Using a Postgres or Custom Store Adapter"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Scenario:"}),"\nYou want to use a Postgres event store in production and an in-memory store for testing, without changing your application logic. You inject the adapter using the ",(0,r.jsx)(t.code,{children:"store()"})," function before any event processing."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { store } from "@rotorsoft/act";\nimport { PostgresStore } from "@rotorsoft/act-pg";\n\nstore(\n  new PostgresStore({\n    host: process.env.PGHOST || "localhost",\n    port: Number(process.env.PGPORT) || 5432,\n    database: process.env.PGDATABASE || "postgres",\n    user: process.env.PGUSER || "postgres",\n    password: process.env.PGPASSWORD || "postgres",\n    schema: "public", // or your custom schema\n    table: "events", // or your custom table\n  })\n);\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"how-to-build-a-custom-store-adapter",children:"How to Build a Custom Store Adapter"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Scenario:"}),"\nYou want to connect your application to a custom event store (e.g., a cloud database). Implement the ",(0,r.jsx)(t.code,{children:"Store"})," interface and inject your adapter using the ",(0,r.jsx)(t.code,{children:"store()"})," function."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import type {\n  Store,\n  EventMeta,\n  Message,\n  Committed,\n  Schemas,\n} from "@rotorsoft/act";\n\nexport class MyCustomStore implements Store {\n  async seed() {\n    /* ... */\n  }\n  async drop() {\n    /* ... */\n  }\n  async dispose() {\n    /* ... */\n  }\n  async commit<E extends Schemas>(\n    stream: string,\n    msgs: Message<E, keyof E>[],\n    meta: EventMeta,\n    expectedVersion?: number\n  ): Promise<Committed<E, keyof E>[]> {\n    // Your persistence logic here\n    return [];\n  }\n  async query<E extends Schemas>(\n    callback: (event: Committed<E, keyof E>) => void,\n    query?: any\n  ): Promise<number> {\n    // Your query logic here\n    return 0;\n  }\n  async fetch<E extends Schemas>(limit: number) {\n    /* ... */ return { streams: [], events: [] };\n  }\n  async lease(leases: any[]) {\n    /* ... */ return [];\n  }\n  async ack(leases: any[]) {\n    /* ... */\n  }\n}\n\n// Inject your custom store\nimport { store } from "@rotorsoft/act";\nstore(new MyCustomStore());\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"advanced-lease-management--reliable-event-stream-processing",children:"Advanced: Lease Management & Reliable Event Stream Processing"}),"\n",(0,r.jsxs)(t.p,{children:["Building a robust custom store adapter is much more than just persisting events\u2014it requires careful design for distributed, reliable, and efficient event stream processing, with ",(0,r.jsx)(t.strong,{children:"lease management"})," at its core."]}),"\n",(0,r.jsx)(t.h3,{id:"what-is-a-lease",children:"What is a Lease?"}),"\n",(0,r.jsx)(t.p,{children:"A lease is a temporary claim on a stream for processing. It ensures that only one process (or worker) is handling a given event stream at a time, supporting distributed, parallel, and fault-tolerant event processing."}),"\n",(0,r.jsx)(t.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"fetch(limit)"})}),": Returns a batch of streams and events that are ready for processing (not blocked or already leased)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"lease(leases)"})}),": Attempts to acquire leases on the given streams. Should atomically mark streams as leased (with a timeout/expiry)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"ack(leases)"})}),": Acknowledges processing is complete, updates stream positions, and releases the lease."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Atomicity:"})," Leasing and updating stream positions must be atomic to avoid race conditions."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Timeouts:"})," Leases must expire if a worker crashes or hangs, so other workers can take over."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Retries:"})," Support for retrying failed streams, with backoff or retry counters."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Blocking:"})," Ability to block streams that are in an error state or require manual intervention."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Scalability:"})," Efficiently handle many streams and high event throughput."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Use transactions for all lease and commit operations."}),"\n",(0,r.jsx)(t.li,{children:"Index your stream and lease tables for fast lookups and updates."}),"\n",(0,r.jsx)(t.li,{children:"Handle lease expiry: If a lease is not acknowledged in time, it should become available for other workers."}),"\n",(0,r.jsx)(t.li,{children:"Support retries and backoff for failed processing."}),"\n",(0,r.jsx)(t.li,{children:"Log and monitor lease acquisition, expiry, and errors for observability."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"sample-lease-table-schema-for-sql-based-stores",children:"Sample Lease Table Schema (for SQL-based stores)"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE streams (\n  stream VARCHAR PRIMARY KEY,\n  at INT NOT NULL DEFAULT -1,\n  retry SMALLINT NOT NULL DEFAULT 0,\n  blocked BOOLEAN NOT NULL DEFAULT FALSE,\n  leased_by UUID,\n  leased_at INT,\n  leased_until TIMESTAMPTZ\n);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"summary-table",children:"Summary Table"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Method"}),(0,r.jsx)(t.th,{children:"Purpose"}),(0,r.jsx)(t.th,{children:"Complexity/Notes"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetch"}),(0,r.jsx)(t.td,{children:"Find streams/events ready for processing"}),(0,r.jsx)(t.td,{children:"Must filter out blocked/leased streams"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"lease"}),(0,r.jsx)(t.td,{children:"Atomically acquire leases on streams"}),(0,r.jsx)(t.td,{children:"Use transactions/locking, set expiry"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ack"}),(0,r.jsx)(t.td,{children:"Release lease, update stream position"}),(0,r.jsx)(t.td,{children:"Must be atomic, handle errors and retries"})]})]})]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Note:"})," Lease management is critical for correctness and reliability in distributed event-driven systems. Study the ",(0,r.jsx)(t.a,{href:"https://github.com/rotorsoft/act/blob/master/libs/act-pg/src/PostgresStore.ts",children:"PostgresStore"})," for a production-grade reference implementation."]}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},6752:function(e,t,s){s.d(t,{Z:()=>i,a:()=>a});var n=s(248);let r={},o=n.createContext(r);function a(e){let t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);