"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9160],{4318:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>c});var a=s(4700);const n={},r=a.createContext(n);function o(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(r.Provider,{value:t},e.children)}},7940:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"concepts/ports-adapters","title":"Ports & Adapters","description":"Background","source":"@site/docs/concepts/ports-adapters.md","sourceDirName":"concepts","slug":"/concepts/ports-adapters","permalink":"/act-root/docs/docs/concepts/ports-adapters","draft":false,"unlisted":false,"editUrl":"https://github.com/rotorsoft/act-root/edit/master/docs/docs/concepts/ports-adapters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Configuration","permalink":"/act-root/docs/docs/concepts/configuration"},"next":{"title":"Calculator Example","permalink":"/act-root/docs/docs/examples/calculator"}}');var n=s(7968),r=s(4318);const o={},c="Ports & Adapters",i={},d=[{value:"Background",id:"background",level:2},{value:"Store Adapters",id:"store-adapters",level:2},{value:"Resource Management",id:"resource-management",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"ports--adapters",children:"Ports & Adapters"})}),"\n",(0,n.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,n.jsx)(t.p,{children:"The Ports & Adapters (Hexagonal) architecture decouples the core logic of your application from external systems such as databases, message queues, or web services. By defining clear interfaces (ports) and providing interchangeable implementations (adapters), this pattern enables flexibility, testability, and maintainability. In this framework, store adapters allow you to swap out storage backends without changing your business logic, and resource management ensures that external connections are handled efficiently and safely."}),"\n",(0,n.jsx)(t.h2,{id:"store-adapters",children:"Store Adapters"}),"\n",(0,n.jsx)(t.p,{children:"Pluggable storage backends allow you to use different databases or event stores with the same application code."}),"\n",(0,n.jsx)(t.h2,{id:"resource-management",children:"Resource Management"}),"\n",(0,n.jsx)(t.p,{children:"Lifecycle management for external resources, such as database connections or message queues, is handled through a consistent interface."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"../api/act.src",children:"API Reference (act)"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);